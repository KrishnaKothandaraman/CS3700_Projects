#!/usr/bin/env python3

import argparse
import json
import random
import select
import socket
from datetime import datetime
from enum import Enum, auto
from typing import List, Tuple
import argparse, socket, time, json, select, struct, sys, math, os
import math

BROADCAST = "FFFF"

class ReplicaState(Enum):
    FOLLOWER  = auto()
    CANDIDATE = auto()
    LEADER    = auto()

class LogEntry:
    term: int
    key: str
    value: str

    def __init__(self, term, value, key):
        self.term = term
        self.value = value
        self.key = key

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))
        self.currentTerm = 0
        self.votedFor = None
        self.votesReceived = set()
        self.majority = math.ceil((len(self.others) + 1) / 2)
        self.log: LogEntry = []
        self.stateMachine = {}
        # queue to buffer messages when leader is not yet known.
        # TODO: Add a timeout logic to this to periodically flush the buffer. For now I just flush it at the end of an election
        self.bufferedMessages = []
        self.leader = "FFFF"
        self.commitIndex = 0
        self.lastApplied = 0
        self.nextIndex = []
        self.matchIndex = []
        self.state = ReplicaState.FOLLOWER
        self.electionTimeout = random.randint(200, 300)
        self.heartBeatTimer = 30 # 30 ms
        self.lastHeartBeatTime = datetime.now()

        print("Replica %s starting up with election timeout %s" % (self.id, self.electionTimeout), flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        print(f"Sending {message}")
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def getLastLogTerm(self):
        if len(self.log) == 0:
            return 0
        
        return self.log[-1].term

    def cancelElectionTimer(self):
        self.lastHeartBeatTime = datetime.now()

    def processGetMessage(self, message):
        
        src = message["src"]
        dst = message["dst"]
        mid = message["MID"]
        key = message["key"]

        if self.state == ReplicaState.FOLLOWER and self.leader != "FFFF":
            response = {"src": self.id, "dst": src, "leader": self.leader, "type": "redirect", "MID": mid}
        elif self.state == ReplicaState.LEADER:
            response = {"src": self.id, "dst": src, "leader": self.leader, "type": "ok", "MID": mid, "value": self.stateMachine.get(key, "")}
        else:
            self.bufferedMessages.append(message)
        self.send(response)

    def processPutMessage(self, message):
                
        src = message["src"]
        dst = message["dst"]
        mid = message["MID"]
        key = message["key"]
        value = message["value"]

        if self.state == ReplicaState.FOLLOWER and self.leader != "FFFF":
            response = {"src": self.id, "dst": src, "leader": self.leader, "type": "redirect", "MID": mid}
        elif self.state == ReplicaState.LEADER:
            logEntry = LogEntry(self.currentTerm, key, value)
            self.log.append(logEntry)
            self.stateMachine[key] = value
            response = {"src": self.id, "dst": src, "leader": self.leader, "type": "ok", "MID": mid}
        else:
            # If we don't know the leader we buffer the message so that we can handle it later on
            self.bufferedMessages.append(message)
            return
        self.send(response)

    def processRequestVote(self, message):

        src = message["src"]
        cTerm = message["term"]
        cLastLogIdx = message["lastLogIdx"]
        cLastLogTerm = message["lastLogTerm"]

        if cTerm > self.currentTerm:
            self.currentTerm = cTerm
            self.votedFor = None
            self.votesReceived = set()
            self.status = ReplicaState.FOLLOWER
        
        lastLogTerm = self.getLastLogTerm()

        cLogOk = (cLastLogTerm > lastLogTerm) or (cLastLogTerm == lastLogTerm and cLastLogIdx >= len(self.log) - 1)
        voteResponse = {"src": self.id, "dst": src, "leader": self.leader,  "type": "RequestVoteResponse", "srcTerm": self.currentTerm}

        if cLogOk and self.state == ReplicaState.FOLLOWER and cTerm == self.currentTerm and (self.votedFor is None or self.votedFor == src):
            self.votedFor = src
            voteResponse["granted"] = True
            self.cancelElectionTimer()
        else:
            voteResponse["granted"] = False
        
        self.send(voteResponse)

    def processRequestVoteResponse(self, message):

        src = message["src"]
        dst = message["dst"]
        srcTerm = message["srcTerm"]
        voteGranted = message["granted"]

        if srcTerm > self.currentTerm:
            self.status = ReplicaState.FOLLOWER
            self.votedFor = None
            self.votesReceived = set()
            self.cancelElectionTimer()
        
        else:
            if (srcTerm == self.currentTerm and self.state != ReplicaState.LEADER) and voteGranted and src not in self.votesReceived:
                self.votesReceived.add(src)
                if len(self.votesReceived) >= self.majority:
                    self.state = ReplicaState.LEADER
                    self.leader = self.id
                    print("I have become the leader!")
                    self.sendAppendEntries()
                    self.flushPendingMessageBuffer()

    def sendAppendEntries(self):
        message = {"src": self.id, "dst": "FFFF", "leader": self.leader,  "type": "AppendEntriesRequest", "term": self.currentTerm}
        self.lastHeartBeatTime = datetime.now()
        self.send(message)
    
    def flushPendingMessageBuffer(self):
        # for now simple logic of just looping through buffered messages and sending reprocessing it
        for message in self.bufferedMessages:
            self.processMessage(message)
        self.bufferedMessages = []

    def processAppendEntriesRequest(self, message):
        
        src = message["src"]
        leaderId = message["leader"]
        leaderTerm = message["term"]

        if leaderTerm > self.currentTerm:
            self.currentTerm = leaderTerm
            self.state = ReplicaState.FOLLOWER
        
        logOk = True # Replace this with log replication logic
        msg = {"src": self.id, "dst": src, "term": self.currentTerm, "type": "AppendEntriesResponse"}
        if (self.currentTerm == leaderTerm) and logOk:
            self.leader = leaderId
            msg["granted"] = True
            self.state = ReplicaState.FOLLOWER
            self.flushPendingMessageBuffer()
            self.cancelElectionTimer()
            print(f"I now bow down to my leader {self.leader} in term {self.currentTerm}", flush=True)
        else:
            msg["granted"] = False

        # this gets set at the end as the leader may get set in the if statement above
        msg["leader"] = self.leader
        self.send(msg)

    def processAppendEntriesResponse(self, message):

        src = message["src"]
        granted = message["granted"]
        srcTerm = message["term"]
        
        if srcTerm > self.currentTerm:
            self.currentTerm = srcTerm
            self.state = ReplicaState.FOLLOWER
            self.votedFor = None
            self.votesReceived = set()
        # to enhance this with the logic to handle failed AppendEntriesRPC

    def processMessage(self, message):
        type = message["type"]
        
        if message["src"] == self.id:
            # message sent by us received back. Should not be possible
            print("Received back a message sent from me. Ignoring")
            return
        if type == "get":
            self.processGetMessage(message)
        elif type == "put":
            self.processPutMessage(message)
        elif type == "RequestVote":
            self.processRequestVote(message)
        elif type == "RequestVoteResponse":
            self.processRequestVoteResponse(message)
        elif type == "AppendEntriesRequest":
            self.processAppendEntriesRequest(message)
        elif type == "AppendEntriesResponse": 
            self.processAppendEntriesResponse(message)
        else:
            # TODO: Let's implemented process RequestVoteRPC then
            raise NotImplementedError(f"Message {type} not implemented yet")

    def hasElectionTimedOut(self):
        return (datetime.now() - self.lastHeartBeatTime).microseconds / 1000 > self.electionTimeout

    def hasHeartBeatTimedOut(self):
        return (datetime.now() - self.lastHeartBeatTime).microseconds / 1000 > self.heartBeatTimer
    
    def startElection(self):
        self.currentTerm += 1
        self.state = ReplicaState.CANDIDATE
        self.votedFor = self.id
        self.votesReceived.add(self.id)
        print(f"I {self.id} have become a candidate for term {self.currentTerm} needing {self.majority} votes to win")
        msg = {
            "type": "RequestVote",
            "src": self.id,
            "dst": "FFFF",
            "term": self.currentTerm,
            "leader": "FFFF",
            "lastLogIdx": len(self.log) - 1,
            "lastLogTerm": self.getLastLogTerm()
        }
        self.cancelElectionTimer()
        self.send(msg)


    def run(self):
        while True:
            if self.state == ReplicaState.LEADER and self.hasHeartBeatTimedOut():
                self.sendAppendEntries()
            if (self.state == ReplicaState.FOLLOWER or self.state == ReplicaState.CANDIDATE) and self.hasElectionTimedOut():
                self.startElection()
            data, addr = self.socket.recvfrom(65535)
            msg = data.decode('utf-8')
            print("Received message '%s'" % (msg,), flush=True)
            self.processMessage(json.loads(msg))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()