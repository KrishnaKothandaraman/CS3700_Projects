#!/usr/bin/env python3

import argparse
import json
import random
import select
import socket
from datetime import datetime
from enum import Enum, auto
from typing import List, Tuple
import argparse, socket, time, json, select, struct, sys, math, os
import math

BROADCAST = "FFFF"

class ReplicaState(Enum):
    FOLLOWER  = auto()
    CANDIDATE = auto()
    LEADER    = auto()

class LogEntry:
    term: int
    key: str
    value: str

    def __init__(self, term, value, key):
        self.term = term
        self.value = value
        self.key = key
    
    def to_dict(self):
        return {"term": self.term, "key": self.key, "value": self.value} 

class Replica:
    def __init__(self, port, id, others):
        # Variables that I do not expect to change during the execution of the algo
        self._port = port
        self._id = id
        self._others = others
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._socket.bind(('localhost', 0))
        self._majority = math.ceil((len(self._others) + 1) / 2)
        self._electionTimeout = random.randint(200, 300)
        self._heartBeatTimer = 30 # 30 ms
        self._lastHeartBeatTime = datetime.now()

        # volatile variables 
        self.currentTerm = 0
        self.votedFor = None
        self.votesReceived = set()
        self.log: List[LogEntry] = []
        self.commitIndex = 0
        self.lastApplied = 0
        self.nextIndex = {}
        self.matchIndex = {}
        self.stateMachine = {}
        self.state = ReplicaState.FOLLOWER
        self.bufferedMessages = []
        self.leader = "FFFF"

        print("Replica %s starting up with election timeout %s" % (self._id, self._electionTimeout), flush=True)
        hello = { "src": self._id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        print(f"Sending {message}")
        self._socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self._port))

    def getLastLogTerm(self):
        if len(self.log) == 0:
            return 0
        
        return self.log[-1].term

    def cancelElectionTimer(self):
        self._lastHeartBeatTime = datetime.now()

    def processGetMessage(self, message):
        
        src = message["src"]
        dst = message["dst"]
        mid = message["MID"]
        key = message["key"]

        if self.state == ReplicaState.FOLLOWER and self.leader != "FFFF":
            response = {"src": self._id, "dst": src, "leader": self.leader, "type": "redirect", "MID": mid}
        elif self.state == ReplicaState.LEADER:
            response = {"src": self._id, "dst": src, "leader": self.leader, "type": "ok", "MID": mid, "value": self.stateMachine.get(key, "")}
        else:
            self.bufferedMessages.append(message)
        self.send(response)

    def processPutMessage(self, message):
                
        src = message["src"]
        dst = message["dst"]
        mid = message["MID"]
        key = message["key"]
        value = message["value"]

        if self.state == ReplicaState.FOLLOWER and self.leader != "FFFF":
            response = {"src": self._id, "dst": src, "leader": self.leader, "type": "redirect", "MID": mid}
        elif self.state == ReplicaState.LEADER:
            logEntry = LogEntry(self.currentTerm, key, value)
            self.log.append(logEntry)
            self.stateMachine[key] = value
            response = {"src": self._id, "dst": src, "leader": self.leader, "type": "ok", "MID": mid}
        else:
            # If we don't know the leader we buffer the message so that we can handle it later on
            self.bufferedMessages.append(message)
            return
        self.send(response)

    def processRequestVote(self, message):

        src = message["src"]
        cTerm = message["term"]
        cLastLogIdx = message["lastLogIdx"]
        cLastLogTerm = message["lastLogTerm"]

        if cTerm > self.currentTerm:
            self.currentTerm = cTerm
            self.votedFor = None
            self.votesReceived = set()
            self.status = ReplicaState.FOLLOWER
        
        lastLogTerm = self.getLastLogTerm()

        cLogOk = (cLastLogTerm > lastLogTerm) or (cLastLogTerm == lastLogTerm and cLastLogIdx >= len(self.log) - 1)
        voteResponse = {"src": self._id, "dst": src, "leader": self.leader,  "type": "RequestVoteResponse", "srcTerm": self.currentTerm}

        if cLogOk and self.state == ReplicaState.FOLLOWER and cTerm == self.currentTerm and (self.votedFor is None or self.votedFor == src):
            self.votedFor = src
            voteResponse["granted"] = True
            self.cancelElectionTimer()
        else:
            voteResponse["granted"] = False
        
        self.send(voteResponse)

    def processRequestVoteResponse(self, message):

        src = message["src"]
        dst = message["dst"]
        srcTerm = message["srcTerm"]
        voteGranted = message["granted"]

        if srcTerm > self.currentTerm:
            self.status = ReplicaState.FOLLOWER
            self.votedFor = None
            self.votesReceived = set()
            self.cancelElectionTimer()
        
        else:
            if (srcTerm == self.currentTerm and self.state != ReplicaState.LEADER) and voteGranted and src not in self.votesReceived:
                self.votesReceived.add(src)
                if len(self.votesReceived) >= self._majority:
                    self.state = ReplicaState.LEADER
                    self.leader = self._id
                    print("I have become the leader!")
                    for node_id in self._others:
                        if node_id == self._id:
                            continue
                        self.matchIndex[node_id] = 0
                        self.nextIndex[node_id] = len(self.log)
                        self.replicateLog(self._id, node_id)
                    self._lastHeartBeatTime = datetime.now()
                    self.flushPendingMessageBuffer()

    def _log_to_json(self, log: List[LogEntry]):
        serializedLog = []
        for entry in log:
            serializedLog.append(entry.to_dict())
        return serializedLog
    def replicateLog(self, sender_id, receiver_id):
        prefix_len = self.nextIndex[receiver_id]

        suffix = self._log_to_json(self.log[min(len(self.log) - 1, prefix_len):])
        prefix_term = 0
        
        #if prefix_len > 0:
        #    prefix_term = self.log[prefix_len - 1].term
        
        message = {
            "src": sender_id,
            "dst": receiver_id,
            "leader": self.leader,
            "type": "AppendEntriesRequest",
            "currentTerm": self.currentTerm,
            "prefixTerm": prefix_term,
            "prefixLength": prefix_len,
            "suffix": suffix,
            "commitIndex": self.commitIndex
        }
        self.send(message)
    
    def flushPendingMessageBuffer(self):
        # for now simple logic of just looping through buffered messages and sending reprocessing it
        for message in self.bufferedMessages:
            self.processMessage(message)
        self.bufferedMessages = []

    def appendNewLogEntries(self):
        pass
        #implement the append entries/commit logic here


    def processAppendEntriesRequest(self, message):
        
        src = message["src"]
        leaderId = message["leader"]
        leaderTerm = message["currentTerm"]
        suffix = message["suffix"]
        prefixLength = message["prefixLength"]
        prefixTerm = message["prefixTerm"]
        commitIndex = message["commitIndex"]
        
        if leaderTerm > self.currentTerm:
            self.currentTerm = leaderTerm
            self.votedFor = None
        if self.currentTerm == leaderTerm:
            self.leader = leaderId
            self.state = ReplicaState.FOLLOWER

        #logOk = (len(self.log) >= prefixLength) and (prefixLength == 0 or self.log[prefixLength].term == prefixTerm)
        logOk = True
        msg = {"src": self._id, "dst": src, "term": self.currentTerm, "type": "AppendEntriesResponse"}
        if self.currentTerm == leaderTerm and logOk:
            self.appendNewLogEntries()
            msg["granted"] = True
            msg["ackLength"] = prefixLength + len(suffix)
            self.cancelElectionTimer()
            print(f"I now bow down to my leader {self.leader} in term {self.currentTerm}", flush=True)
        else:
            msg["granted"] = False
            msg["ackLength"] = 0

        # this gets set at the end as the leader may not get set in the if statement above
        msg["leader"] = self.leader
        self.send(msg)
        self.flushPendingMessageBuffer()

    def processAppendEntriesResponse(self, message):

        src = message["src"]
        granted = message["granted"]
        srcTerm = message["term"]
        ackLength = message["ackLength"]

        if srcTerm == self.currentTerm and self.state == ReplicaState.LEADER:
            if ackLength > self.matchIndex[src]:
                self.nextIndex[src] = ackLength
                self.matchIndex[src] = ackLength

        # enchance this with failed append entries rpc        

        if srcTerm > self.currentTerm:
            self.currentTerm = srcTerm
            self.state = ReplicaState.FOLLOWER
            self.votedFor = None
            self.votesReceived = set()
        # to enhance this with the logic to handle failed AppendEntriesRPC

    def processMessage(self, message):
        type = message["type"]
        
        if message["src"] == self._id:
            # message sent by us received back. Should not be possible
            print("Received back a message sent from me. Ignoring")
            return
        if type == "get":
            self.processGetMessage(message)
        elif type == "put":
            self.processPutMessage(message)
        elif type == "RequestVote":
            self.processRequestVote(message)
        elif type == "RequestVoteResponse":
            self.processRequestVoteResponse(message)
        elif type == "AppendEntriesRequest":
            self.processAppendEntriesRequest(message)
        elif type == "AppendEntriesResponse": 
            self.processAppendEntriesResponse(message)
        else:
            # TODO: Let's implemented process RequestVoteRPC then
            raise NotImplementedError(f"Message {type} not implemented yet")

    def hasElectionTimedOut(self):
        return (datetime.now() - self._lastHeartBeatTime).microseconds / 1000 > self._electionTimeout

    def hasHeartBeatTimedOut(self):
        return (datetime.now() - self._lastHeartBeatTime).microseconds / 1000 > self._heartBeatTimer
    
    def startElection(self):
        self.currentTerm += 1
        self.state = ReplicaState.CANDIDATE
        self.votedFor = self._id
        self.votesReceived.add(self._id)

        print(f"I {self._id} have become a candidate for term {self.currentTerm} needing {self._majority} votes to win")
        msg = {
            "type": "RequestVote",
            "src": self._id,
            "dst": "FFFF",
            "term": self.currentTerm,
            "leader": "FFFF",
            "lastLogIdx": len(self.log) - 1,
            "lastLogTerm": self.getLastLogTerm()
        }
        self.cancelElectionTimer()
        self.send(msg)


    def run(self):
        while True:
            if self.state == ReplicaState.LEADER and self.hasHeartBeatTimedOut():
                for node_id in self._others:
                    if node_id == self._id:
                        continue
                    self.replicateLog(self._id, node_id)
                self._lastHeartBeatTime = datetime.now()
            if (self.state == ReplicaState.FOLLOWER or self.state == ReplicaState.CANDIDATE) and self.hasElectionTimedOut():
                self.startElection()
            data, addr = self._socket.recvfrom(65535)
            msg = data.decode('utf-8')
            print("Received message '%s'" % (msg,), flush=True)
            self.processMessage(json.loads(msg))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()