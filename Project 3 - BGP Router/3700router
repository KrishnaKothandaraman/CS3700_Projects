#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dataclasses import dataclass
from enum import Enum, auto
from typing import List, Optional
from network import Network
from table import Table

# method given in the starter code.
def our_addr(dst):
    quads = list(int(qdn) for qdn in dst.split('.'))
    quads[3] = 1
    return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

class Router:
    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        print(connections) 
        self.asn = asn
        self.update_messages = []
        self.withdraw_messages = []
        self.table: Table = Table()
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": our_addr(neighbor), "dst": neighbor, "msg": {}}))

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                received_message, addr = conn.recvfrom(65535)
                message_source_network = None
                for network_name, sock in self.sockets.items():
                    if sock == conn:
                        message_source_network = network_name
                        break
                msg = received_message.decode('utf-8')
                self.processMessage(json.loads(msg))


                print(f"Received message {msg} from {message_source_network} on {self.ports[message_source_network]}")
        return

    def handleUpdateMessage(self, msg):
        network_msg = msg['msg']

        src = msg['src']
        network = network_msg['network']
        netmask = network_msg['netmask']
        localpref = network_msg['localpref']
        selfOrigin = network_msg['selfOrigin']
        ASPath = network_msg['ASPath']
        origin = network_msg['origin']
        
        network: Network = Network(network, netmask, localpref, selfOrigin, ASPath, origin)
        self.table.add_network(src, network)

        self.forwardUpdateMessage(msg)

    def _sendMessageToNeighboursWithPredictate(self, msg, predicate):

        for neighbour, relation in self.relations.items():
            if predicate(neighbour, relation):
                continue
            msg['src'] = our_addr(neighbour)
            msg['dst'] = neighbour
            self.send(neighbour, json.dumps(msg))

    def forwardUpdateMessage(self, msg):
        src = msg['src']

        if src not in self.relations:
            print("WARNING: src not in relations: {src}")
            return

        msg = {
            "type": "update",
            "src": "", #tbd
            "dst": "", #tbd,
            "msg" : {
                "network": msg['msg']["network"],
                "netmask": msg['msg']['netmask'],
                'ASPath': [self.asn] + msg['msg']['ASPath']
            }
        }
        relation = self.relations[src]
        if relation == "cust":
           self._sendMessageToNeighboursWithPredictate(msg, lambda x, y: x == src)
        elif relation == "peer" or relation == "prov":
            self._sendMessageToNeighboursWithPredictate(msg, lambda x, y: src == x or self.relations[y] != "cust")    
        else:
            print("WARNING: Unknow relationship with src: {src}. This should never happen")

    def handleWithdrawMessage(self, msg):
        assert False, "Not Implemented yet"

    def handleDataMessage(self, msg):
        
        src = msg['src']
        dst = msg['dst']
        next_hop = self.table.get_next_hop_router(dst)

        if not next_hop:
            # no next hop. Return back to source saying no route
            msg = {
                "src": our_addr(dst),
                "dst": dst,
                "msg": {},
                "type": "no route"
            }
        else:
            msg['src'] = our_addr(next_hop)
            msg['dst'] = dst
        
        print(f"Forwarding/Responding to data message with {msg}")
        self.send(next_hop, json.dumps(msg))



    def handleDumpMessage(self, msg):
        
        src = msg['src']
        
        table_contents = self.table.dump()
        msg = {
            'src': our_addr(src),
            'dst': src,
            "type": "table",
            "msg": table_contents
        }

        self.send(msg['dst'], json.dumps(msg))



    def processMessage(self, msg):

        if msg['type'] == "update":
            self.handleUpdateMessage(msg)
        elif msg['type'] == "withdraw":
            self.handleWithdrawMessage(msg)
        elif msg["type"] == "data":
            self.handleDataMessage(msg)
        elif msg['type'] == "dump":
            self.handleDumpMessage(msg)
        else:
            assert False, f"Message {msg['type']} not implemented yet"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
