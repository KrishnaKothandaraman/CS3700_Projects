#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dataclasses import dataclass
from enum import Enum, auto
from typing import List, Optional
from network import Network
from table import Table

# method given in the starter code.
def our_addr(dst):
    quads = list(int(qdn) for qdn in dst.split('.'))
    quads[3] = 1
    return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

class Router:
    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        self.update_messages = []
        self.withdraw_messages = []
        self.table: Table = Table()
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": our_addr(neighbor), "dst": neighbor, "msg": {}}))

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                received_message, addr = conn.recvfrom(65535)
                message_source_network = None
                for network_name, sock in self.sockets.items():
                    if sock == conn:
                        message_source_network = network_name
                        break
                msg = received_message.decode('utf-8')
                self.processMessage(json.loads(msg))


                print(f"Received message {msg} from {message_source_network} on {self.ports[message_source_network]}")
        return

    def handleUpdateMessage(self, msg):
        network_msg = msg['msg']

        src = msg['src']
        network = network_msg['network']
        netmask = network_msg['netmask']
        localpref = network_msg['localpref']
        selfOrigin = network_msg['selfOrigin']
        ASPath = network_msg['ASPath']
        origin = network_msg['origin']
        
        network: Network = Network(network, netmask, localpref, selfOrigin, ASPath, origin)
        self.table.add_network(src, network)

    def handleWithdrawMessage(self, msg):
        assert False, "Not Implemented yet"

    def handleDataMessage(self, msg):
        assert False, "Not Implemented yet"

    def handleDumpMessage(self, msg):
        assert False, "Not Implemented yet"



    def processMessage(self, msg):

        if msg['type'] == "update":
            self.handleUpdateMessage(msg)
        elif msg['type'] == "withdraw":
            self.handleWithdrawMessage(msg)
        elif msg["type"] == "data":
            self.handleDataMessage(msg)
        elif msg['type'] == "dump":
            self.handleDumpMessage(msg)
        else:
            assert False, f"Message {msg['type']} not implemented yet"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
